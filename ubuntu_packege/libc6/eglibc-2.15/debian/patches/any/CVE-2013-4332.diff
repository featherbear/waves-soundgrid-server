Description: fix denial of service and possible code execution via
 overflows in memory allocator
Origin: backport, https://sourceware.org/git/?p=glibc.git;a=commit;h=1159a193696ad48ec86e5895f6dee3e539619c0e
Origin: backport, https://sourceware.org/git/?p=glibc.git;a=commit;h=55e17aadc1ef17a1df9626fb0e9fba290ece3331
Origin: backport, https://sourceware.org/git/?p=glibc.git;a=commit;h=b73ed247781d533628b681f57257dc85882645d3
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=15855
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=15856
Bug: https://sourceware.org/bugzilla/show_bug.cgi?id=15857
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=722536

Index: eglibc-2.15/malloc/malloc.c
===================================================================
--- eglibc-2.15.orig/malloc/malloc.c	2013-09-27 13:47:03.808967542 -0400
+++ eglibc-2.15/malloc/malloc.c	2013-09-27 13:47:03.792967541 -0400
@@ -3098,6 +3098,13 @@
   /* Otherwise, ensure that it is at least a minimum chunk size */
   if (alignment <  MINSIZE) alignment = MINSIZE;
 
+  /* Check for overflow.  */
+  if (bytes > SIZE_MAX - alignment - MINSIZE)
+    {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+
   arena_get(ar_ptr, bytes + alignment + MINSIZE);
   if(!ar_ptr)
     return 0;
@@ -3140,6 +3147,13 @@
 
   size_t pagesz = GLRO(dl_pagesize);
 
+  /* Check for overflow.  */
+  if (bytes > SIZE_MAX - pagesz - MINSIZE)
+    {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+
   __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, size_t,
 					__const __malloc_ptr_t)) =
     force_reg (__memalign_hook);
@@ -3190,6 +3204,13 @@
   size_t page_mask = GLRO(dl_pagesize) - 1;
   size_t rounded_bytes = (bytes + page_mask) & ~(page_mask);
 
+  /* Check for overflow.  */
+  if (bytes > SIZE_MAX - 2*pagesz - MINSIZE)
+    {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+
   __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, size_t,
 					__const __malloc_ptr_t)) =
     force_reg (__memalign_hook);

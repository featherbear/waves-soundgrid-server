Description: fix another overflow and an infinite loop
Origin: backport, https://sourceware.org/git/?p=glibc.git;h=321e26847188300173a5dc0ca42c2ff7b9bf7a78
Origin: backport, https://sourceware.org/git/?p=glibc.git;h=a56ee40b176d0a3f47f2a7eb75208f2e3763c9fd

Index: eglibc-2.15/malloc/hooks.c
===================================================================
--- eglibc-2.15.orig/malloc/hooks.c	2011-10-24 20:37:10.000000000 -0400
+++ eglibc-2.15/malloc/hooks.c	2014-07-25 13:25:35.538830571 -0400
@@ -333,10 +333,21 @@
   if (alignment <= MALLOC_ALIGNMENT) return malloc_check(bytes, NULL);
   if (alignment <  MINSIZE) alignment = MINSIZE;
 
-  if (bytes+1 == 0) {
-    __set_errno (ENOMEM);
-    return NULL;
-  }
+  /* If the alignment is greater than SIZE_MAX / 2 + 1 it cannot be a
+     power of 2 and will cause overflow in the check below.  */
+  if (alignment > SIZE_MAX / 2 + 1)
+    {
+      __set_errno (EINVAL);
+      return 0;
+    }
+
+  /* Check for overflow.  */
+  if (bytes > SIZE_MAX - alignment - MINSIZE)
+    {
+      __set_errno (ENOMEM);
+      return 0;
+    }
+
   (void)mutex_lock(&main_arena.mutex);
   mem = (top_check() >= 0) ? _int_memalign(&main_arena, alignment, bytes+1) :
     NULL;
Index: eglibc-2.15/malloc/malloc.c
===================================================================
--- eglibc-2.15.orig/malloc/malloc.c	2014-07-25 13:24:56.574830763 -0400
+++ eglibc-2.15/malloc/malloc.c	2014-07-25 13:25:35.542830571 -0400
@@ -3098,6 +3098,14 @@
   /* Otherwise, ensure that it is at least a minimum chunk size */
   if (alignment <  MINSIZE) alignment = MINSIZE;
 
+  /* If the alignment is greater than SIZE_MAX / 2 + 1 it cannot be a
+     power of 2 and will cause overflow in the check below.  */
+  if (alignment > SIZE_MAX / 2 + 1)
+    {
+      __set_errno (EINVAL);
+      return 0;
+    }
+
   /* Check for overflow.  */
   if (bytes > SIZE_MAX - alignment - MINSIZE)
     {
